#include <opencv2/opencv.hpp>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <vector>

using namespace cv;
char keyboard;
int x = 3;
int y = 3;
double sigma = 0.3*(3/2 - 1) + 0.8;
int i = 0;
RNG rng(12345);


Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2;
  std::vector<std::vector<Point> > contours;
  std::vector<Vec4i> hierarchy;

//void findConvexityDefects(std::vector<Point> contour, std::vector<int> hull, std::vector<Point> convexDefects);
  
int main(int, char**)
{
    //VideoCapture cap(0); 
    VideoCapture cap("test2.mp4");  // open the default camera
    pMOG2 = createBackgroundSubtractorMOG2();
    
    Mat frame;
    Mat blframe;
    Mat blurred;
    Mat threshold_output;
    //Mat frame2(Size(640, 420),CV_8UC3);
    //createTrackbars(); // create trackbars

    if(!cap.isOpened())   
        return -1;
    keyboard = 0;
    while( keyboard != 'q'){
        //cap>>frame; // new frame from camera
        cap.read(frame);
        //cv::cvtColor(frame, blframe, CV_RGB2GRAY);
        //GaussianBlur(blframe,blframe,Size(x,y),sigma,0.0,4);
        
        cv::cvtColor(frame, blframe, CV_RGB2GRAY);
        GaussianBlur(blframe,blurred,Size(25,25),0);
        //threshold( blurred, threshold_output, 127, 255, THRESH_BINARY);
        //findContours( threshold_output.clone(), contours, hierarchy, RETR_TREE, CHAIN_APPROX_NONE,  Point(0, 0)  );
       
        if(i < 50){
            pMOG2->apply(blurred, fgMaskMOG2,1);
            //std::cout << i << std::endl;
            
        }
        else{
            pMOG2->apply(blurred, fgMaskMOG2,0);
        }
        i++;
        
        threshold( fgMaskMOG2, threshold_output, 100, 255, THRESH_BINARY );
        findContours( threshold_output, contours, hierarchy, CV_RETR_TREE, CHAIN_APPROX_NONE, Point(0, 0) );
        
        std::vector<std::vector<Point> >hull( contours.size() );
        std::vector<Vec4i> convexityDefects;
        for( int i = 0; i < contours.size(); i++ )
        {  convexHull( Mat(contours[i]), hull[i], false );
           //if(contours.size() > 2 || hull.size() > 2){
           //convexityDefects(contours[i], hull[i], defect_points[i]);
           //}
        }
        
        //convexityDefects(contours,hull,convexityDefects);
        //std::cout << defect_points.size() << std::endl;
        
        Mat drawing = Mat::zeros( frame.size(), CV_8UC3 );
        for( int i = 0; i< contours.size(); i++ )
           {
             Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
             drawContours( drawing, contours, i, color, 2, 8, hierarchy, 0, Point() );
             //drawContours( drawing, hull, i, color, 1, 8, std::vector<Vec4i>(), 0, Point() );
             
           }
        
        
        
        imshow("Original Video", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        imshow( "Contours", drawing );
        keyboard = (char)waitKey( 30 );
    }
    return 0;
}
/*
void findConvexityDefects(std::vector<Point> contour, std::vector<int> hull, std::vector<Point> convexDefects){
    if(hull.size() > 0 && contour.size() > 0){
    CvSeq* contourPoints;
    CvSeq* defects;
    CvMemStorage* storage;
    CvMemStorage* strDefects;
    CvMemStorage* contourStr;
    CvConvexityDefect *defectArray = 0;

    strDefects = cvCreateMemStorage();
    defects = cvCreateSeq( CV_SEQ_KIND_GENERIC|CV_32SC2, sizeof(CvSeq),sizeof(CvPoint), strDefects );

    //We transform our vector<Point> into a CvSeq* object of CvPoint.
    contourStr = cvCreateMemStorage();
    contourPoints = cvCreateSeq(CV_SEQ_KIND_GENERIC|CV_32SC2, sizeof(CvSeq), sizeof(CvPoint), contourStr);
    for(int i=0; i<(int)contour.size(); i++) {
        CvPoint cp = {contour[i].x,  contour[i].y};
        cvSeqPush(contourPoints, &cp);
    }

    //Now, we do the same thing with the hull index
    int count = (int)hull.size();
    //int hullK[count];
    int* hullK = (int*)malloc(count*sizeof(int));
    for(int i=0; i<count; i++){hullK[i] = hull.at(i);}
    CvMat hullMat = cvMat(1, count, CV_32SC1, hullK);

    //We calculate convexity defects
    storage = cvCreateMemStorage(0);
    defects = cvConvexityDefects(contourPoints, &hullMat, storage);
    defectArray = (CvConvexityDefect*)malloc(sizeof(CvConvexityDefect)*defects->total);
    cvCvtSeqToArray(defects, defectArray, CV_WHOLE_SEQ);
    //printf("DefectArray %i %i\n",defectArray->end->x, defectArray->end->y);

    //We store defects points in the convexDefects parameter.
    for(int i = 0; i<defects->total; i++){
        CvPoint ptf;
        ptf.x = defectArray[i].depth_point->x;
        ptf.y = defectArray[i].depth_point->y;
        convexDefects.push_back(ptf);
    }

    //We release memory
    cvReleaseMemStorage(contourStr);
    cvReleaseMemStorage(strDefects);
    cvReleaseMemStorage(storage);
    }
}*/